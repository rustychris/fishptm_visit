/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtFISHPTMFileFormat.C                           //
// ************************************************************************* //

#include <avtFISHPTMFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkPoints.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>
//#include <vtkCellData.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

#include <DebugStream.h>

using     std::string;


// ****************************************************************************
//  Method: avtFISHPTMFileFormat constructor
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

avtFISHPTMFileFormat::avtFISHPTMFileFormat(const char *filename)
    : avtMTSDFileFormat(&filename, 1)
{
  debug1 << "FISHPTM: start of ctor" << endl;

  // INITIALIZE DATA MEMBERS
  file.open(filename,std::ios::binary);
  if ( !file ) {
    debug1 << "Failed to open '" << filename << "'" << endl;
    return;
  }
  
  file.seekg(0, std::ios::end);
  eof = file.tellg();

  file.seekg(0, std::ios::beg);
  
  n_timesteps=-1;

  offsets.resize(0);
  read_header();
  // while we are here, record the location of the first record,
  // but don't scan yet.
  offsets.push_back(file.tellg());

  // while developing, go ahead and scan...
  scan_timesteps();
  
  debug1 << "FISHPTM: end of ctor" << endl;
}

// read header information to know how many fields are included.
// assumes that file is open
void avtFISHPTMFileFormat::read_header(void) {
  int bytes_read;
  file.seekg( 0, std::ios::beg );

  file.read((char*)&Nattr,sizeof(Nattr));
  debug1 << "Nattr = "<< Nattr << endl;

  for(int i=0;i<Nattr;i++) {
    Attr attr;
    char buff[80];
    file.read((char*)&(attr.idx),sizeof(attr.idx));
    file.read(buff,80);
    attr.type=buff;
    file.read(buff,80);
    attr.name=buff;
    attrs.push_back(attr);
    debug1 << "  " << attr.idx << " " << attr.type << " " << attr.name << endl;
  }
}

void avtFISHPTMFileFormat::activate_step(int step) {
  debug1 << "FISHPTM: top of activate_step" << endl;
  
  file.seekg(offsets[step],ios::beg);
  debug1 << "FISHPTM: activate_step " << step << "   offset=" << offsets[step]
         << "   position=" << file.tellg() << endl;
  file.read((char*)&current_step_header,sizeof(current_step_header));
  active_step=step;
}

void avtFISHPTMFileFormat::scan_timesteps(void) {
  debug1 << "FISHPTM: Top of scan_timesteps" << endl;
  
  // Scan the file to count timesteps and find the
  // offsets
  // assumes fp is open, and the first timestep is
  // known (probably just the first offset)
  int step=offsets.size()-1;
  
  for ( ; file ; step++ ) {
    activate_step(step);
    
    debug1 << "Step " << step << " has " << current_step_header.Npart << " particles" << endl;
    ios::streamoff frame_bytes = sizeof(current_step_header) + current_step_header.Npart * (2*4 + 3*8);
    ios::streampos next_offset=offsets[step] + frame_bytes;
    if ( next_offset >= eof ) {
      debug1 << "Found end of file" << endl;
      break;
    }
    offsets.push_back(next_offset);
  }

  n_timesteps=offsets.size();
  debug1 << "FISHPTM: end of scan_timesteps, n_timesteps=" << n_timesteps << endl;
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

int
avtFISHPTMFileFormat::GetNTimesteps(void)
{
  if ( n_timesteps < 0 ) scan_timesteps();
  return n_timesteps;
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

void
avtFISHPTMFileFormat::FreeUpResources(void)
{
  // could close the file..
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

void
avtFISHPTMFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  //
  // CODE TO ADD A MESH
  //
  string meshname = "particles";
  avtMeshType mt = AVT_POINT_MESH;

  int nblocks = 1;
  int block_origin = 0;
  int spatial_dimension = 3;
  int topological_dimension = 0;
  double *extents = NULL;

  // Here's the call that tells the meta-data object that we have a mesh:
  AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
                    spatial_dimension, topological_dimension);

  // Start with just the mesh
  
  // // CODE TO ADD A SCALAR VARIABLE
  // string mesh_for_this_var = meshname; 
  // string varname = "z";
  // 
  // // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  // 
  // Here's the call that tells the meta-data object that we have a var:
  AddScalarVarToMetaData(md, "status", meshname, AVT_NODECENT);

  debug1 << "FISHPTM: end of populate database metadata" << endl;
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

vtkDataSet *
avtFISHPTMFileFormat::GetMesh(int timestate, const char *meshname)
{
  // probably this should be dynamic, based on the attributes read in earlier.
  int32_t part_id;
  double xyz[3];
  int32_t active;

  activate_step(timestate);
  
  vtkPoints *points = vtkPoints::New();
  points->SetNumberOfPoints( current_step_header.Npart );
  float *pts = (float *) points->GetVoidPointer(0);

  for(int i=0;i<current_step_header.Npart;i++) {
    file.read((char*)&part_id,sizeof(part_id));
    file.read((char*)xyz, sizeof(xyz));
    file.read((char*)&active,sizeof(active));
    pts[3*i  ]=(float)xyz[0];
    pts[3*i+1]=(float)xyz[1];
    pts[3*i+2]=(float)xyz[2];
  }

  /* and then make a grid out of it */
  vtkUnstructuredGrid *pntmesh = vtkUnstructuredGrid::New();
  pntmesh->SetPoints(points);
  points->Delete();

  for(vtkIdType i=0;i<current_step_header.Npart;i++) {
    pntmesh->InsertNextCell(VTK_VERTEX,1,&i);
  }

  debug1 << "FISHPTM: end of GetMesh" << endl;

  return pntmesh;
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

vtkDataArray *
avtFISHPTMFileFormat::GetVar(int timestate, const char *varname)
{
  if ( strcmp(varname,"status")==0 ) {
    // terribly inefficient, but it's just not the time to write this well.
    int32_t part_id;
    double xyz[3];
    int32_t active;
    
    activate_step(timestate);

    vtkFloatArray *rv = vtkFloatArray::New();
    rv->SetNumberOfTuples(current_step_header.Npart);
  
    for(int i=0;i<current_step_header.Npart;i++) {
      file.read((char*)&part_id,sizeof(part_id));
      file.read((char*)xyz, sizeof(xyz));
      file.read((char*)&active,sizeof(active));
      rv->SetTuple1(i,active);
    }
    return rv;
  } else {
    // start with just geometry
    EXCEPTION1(InvalidVariableException, varname);
  }

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}


// ****************************************************************************
//  Method: avtFISHPTMFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Thu May 9 12:17:48 PDT 2019
//
// ****************************************************************************

vtkDataArray *
avtFISHPTMFileFormat::GetVectorVar(int timestate, const char *varname)
{
  EXCEPTION1(InvalidVariableException, varname);
    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}
